"""
TODO
"""
from typing import Any, Generator, List, Tuple, Optional
from typing import re as BuiltInReType
import re

import ahocorasick

from cnt.rulebase import workflow, const, utils

IntervalType = Tuple[int, int]
IntervalGeneratorType = Generator[IntervalType, None, None]


def _next_interval(intervals: IntervalGeneratorType) -> Optional[IntervalType]:
    try:
        return next(intervals)
    except StopIteration:
        return None


def _build_ac_automation(keys: List[str]) -> Any:
    atm = ahocorasick.Automaton()  # pylint: disable=c-extension-no-member
    for idx, key in enumerate(keys):
        atm.add_word(key, (idx, key))
    atm.make_automaton()
    return atm


def _ac_automation_match(text: str, ac_automation: Any) -> IntervalGeneratorType:
    prev_start, prev_end = -1, -1

    # ``iter``` will return ``end`` in accending order, see
    # https://github.com/WojciechMula/pyahocorasick/blob/484b1f13549fc9bdeb9868d8a1711d1861f804c3/py/pyahocorasick.py#L229-L252
    # Also note the ``[start, end]`` generated by ``iter`` are closed interval.
    for end, (_, key) in ac_automation.iter(text):
        start = end + 1 - len(key)

        if prev_start < 0:
            # init.
            prev_start, prev_end = start, end
        elif start <= prev_end + 1:
            # check the interleaved case.
            prev_end = end
        else:
            # should return the previous interval. Note we yield half-opened interval here.
            yield (prev_start, prev_end + 1)
            prev_start, prev_end = start, end

    # yield the last interval.
    if prev_start >= 0:
        yield (prev_start, prev_end + 1)


def _re_pattern_from_sorted_intervals(sorted_intervals: List[IntervalType]) -> BuiltInReType:
    inner = [f'{chr(lb)}-{chr(ub)}' for lb, ub in sorted_intervals]
    joined_inner = ''.join(inner)
    pattern = f'[{joined_inner}]+'

    return re.compile(pattern, re.UNICODE)


class IntervalLabeler(workflow.BasicSequentialLabeler):

    def __init__(self, input_sequence: str):
        super().__init__(input_sequence)

        self.intervals = self.initialize_intervals()
        self.cur_interval = _next_interval(self.intervals)

    def initialize_intervals(self) -> IntervalGeneratorType:
        raise NotImplementedError()

    def label(self, index: int) -> bool:
        if self.cur_interval is None or index < self.cur_interval[0]:
            return False

        if index < self.cur_interval[1]:
            return True

        self.cur_interval = _next_interval(self.intervals)
        return False


class SentenceEndingLabeler(IntervalLabeler):
    """
    Mark sentence endings based on
    :py:const:`cnt.rulebase.const.sentence_endings.EM_SENTENCE_ENDINGS`

    Time & space complexity: `O(1)`.
    """

    AC_AUTOMATION = _build_ac_automation(const.EM_SENTENCE_ENDINGS)

    def initialize_intervals(self) -> IntervalGeneratorType:
        return _ac_automation_match(self.input_sequence, self.AC_AUTOMATION)


class CommaLabeler(workflow.BasicSequentialLabeler):
    """
    Mark comma.

    Time & space complexity: `O(1)`.
    """

    COMMAS = (chr(0xFF0C), chr(0x201A), ',')

    def label(self, index: int) -> bool:
        return self.input_sequence[index] in self.COMMAS


class WhitespaceLabeler(IntervalLabeler):
    """
    Mark unicode whitespace.

    Time & space complexity: `O(1)`.
    """

    WHITESPACE_PATTERN = re.compile(r'\s+')

    def initialize_intervals(self) -> IntervalGeneratorType:
        return (match.span() for match in self.WHITESPACE_PATTERN.finditer(self.input_sequence))


class SentenceValidCharacterLabeler(IntervalLabeler):
    """
    Mark valid character of chinese sentence.

    Time & space complexity: `O(1)`.
    """

    SENTENCE_VALID_CHARS_PATTERN = _re_pattern_from_sorted_intervals(
            utils.sorted_chain(
                    const.ITV_CHINESE_CHARS,
                    const.ITV_ENGLISH_CHARS,
                    const.ITV_DIGITS,
                    const.ITV_DELIMITERS,
            ))

    def initialize_intervals(self) -> IntervalGeneratorType:
        return (match.span()
                for match in self.SENTENCE_VALID_CHARS_PATTERN.finditer(self.input_sequence))


class SentenceSegementationConfig(workflow.BasicConfig):

    def __init__(self, enable_comma_ending: bool):
        self.enable_comma_ending = enable_comma_ending


class SentenceSegementationLabelProcessor(workflow.BasicLabelProcessor):

    def _labels_indicate_sentence_ending(self, labels: workflow.LabelsType) -> bool:
        return labels[SentenceEndingLabeler] or (self.config.enable_comma_ending and
                                                 labels[CommaLabeler])

    def result(self) -> IntervalGeneratorType:
        """
        Generate intervals indicating the valid sentences.
        """
        index = -1
        labels = None

        while True:

            # 1. Find the start of the sentence.
            start = -1
            while True:
                # Check the ``labels`` generated from step (2).
                if labels is None:
                    # https://www.python.org/dev/peps/pep-0479/
                    try:
                        index, labels = next(self.index_labels_generator)
                    except StopIteration:
                        return
                # Check if we found a valid sentence char.
                if labels[SentenceValidCharacterLabeler]:
                    start = index
                    break
                # Trigger next(...) action.
                labels = None
                index = -1

            # 2. Find the ending.
            end = -1
            try:
                while True:
                    index, labels = next(self.index_labels_generator)
                    print(index)

                    # Detected invalid char.
                    if not labels[SentenceValidCharacterLabeler] and not labels[WhitespaceLabeler]:
                        end = index
                        break

                    # Detected sentence ending.
                    if self._labels_indicate_sentence_ending(labels):
                        # Consume the ending span.
                        while True:
                            index, labels = next(self.index_labels_generator)
                            if not self._labels_indicate_sentence_ending(labels):
                                end = index
                                break
                        # yeah we found the ending.
                        break
            except StopIteration:
                end = len(self.input_sequence)
                # Trigger next(...) action.
                labels = None
                index = -1

            yield start, end


SentenceRetType = Tuple[str, IntervalType]


class SentenceSegementationOutputGenerator(workflow.BasicOutputGenerator):

    def result(self) -> List[SentenceRetType]:
        return [(self.input_sequence[start:end], (start, end))
                for start, end in self.label_processor_result]


def sentseg(text: str, enable_comma_ending: bool = False) -> List[SentenceRetType]:
    config = SentenceSegementationConfig(enable_comma_ending=enable_comma_ending)

    sentseg_workflow = workflow.BasicWorkflow(
            sequential_labeler_classes=[
                    SentenceEndingLabeler,
                    CommaLabeler,
                    WhitespaceLabeler,
                    SentenceValidCharacterLabeler,
            ],
            label_processor_class=SentenceSegementationLabelProcessor,
            output_generator_class=SentenceSegementationOutputGenerator,
            config=config,
    )

    return sentseg_workflow.result(text)
